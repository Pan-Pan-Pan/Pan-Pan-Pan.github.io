<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>BUAA Software CO｜计算机组成原理概要1 | Riccardo's Blog</title><meta name="author" content="Chou,1425650574@qq.com"><meta name="copyright" content="Chou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="BUAA Software CO｜计算机组成原理概要101 绪论冯诺依曼架构 计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。 各基本部件的功能 存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令。 控制器应能自动取出指令来执行。 运算器应能进行加&#x2F;减&#x2F;乘&#x2F;除四种基本算术运算，并且也能进行一些逻辑运算和附加运算。 操作人员可以通过输入设备">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA Software CO｜计算机组成原理概要1">
<meta property="og:url" content="http://example.com/2023/01/07/CO1/index.html">
<meta property="og:site_name" content="Riccardo&#39;s Blog">
<meta property="og:description" content="BUAA Software CO｜计算机组成原理概要101 绪论冯诺依曼架构 计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。 各基本部件的功能 存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令。 控制器应能自动取出指令来执行。 运算器应能进行加&#x2F;减&#x2F;乘&#x2F;除四种基本算术运算，并且也能进行一些逻辑运算和附加运算。 操作人员可以通过输入设备">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/background.jpg">
<meta property="article:published_time" content="2023-01-07T13:25:52.000Z">
<meta property="article:modified_time" content="2023-01-15T08:14:53.088Z">
<meta property="article:author" content="Chou">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/07/CO1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA Software CO｜计算机组成原理概要1',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-01-15 16:14:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/img.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Photos</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Riccardo's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Photos</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA Software CO｜计算机组成原理概要1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-07T13:25:52.000Z" title="发表于 2023-01-07 21:25:52">2023-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-15T08:14:53.088Z" title="更新于 2023-01-15 16:14:53">2023-01-15</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="BUAA-Software-CO｜计算机组成原理概要1"><a href="#BUAA-Software-CO｜计算机组成原理概要1" class="headerlink" title="BUAA Software CO｜计算机组成原理概要1"></a>BUAA Software CO｜计算机组成原理概要1</h1><h2 id="01-绪论"><a href="#01-绪论" class="headerlink" title="01 绪论"></a>01 绪论</h2><h3 id="冯诺依曼架构"><a href="#冯诺依曼架构" class="headerlink" title="冯诺依曼架构"></a>冯诺依曼架构</h3><ul>
<li><strong>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。</strong></li>
<li><strong>各基本部件的功能</strong><ul>
<li>存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令。</li>
<li>控制器应能自动取出指令来执行。</li>
<li>运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算。</li>
<li>操作人员可以通过输入设备、输出设备和主机进行通信。</li>
</ul>
</li>
<li><strong>内部以二进制表示指令和数据。</strong>每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。</li>
<li>采用<strong>“存储程序”</strong>工作方式：任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。</li>
</ul>
<h3 id="程序编译与加载"><a href="#程序编译与加载" class="headerlink" title="程序编译与加载"></a>程序编译与加载</h3><p><img src="/2023/01/07/CO1/截屏2022-12-26 23.33.32.png" alt="截屏2022-12-26 23.33.32" style="zoom:50%;"></p>
<h3 id="两类指令集"><a href="#两类指令集" class="headerlink" title="两类指令集"></a>两类指令集</h3><p><img src="/2023/01/07/CO1/截屏2022-12-26 23.38.37.png" alt="截屏2022-12-26 23.38.37" style="zoom: 50%;"></p>
<p><img src="/2023/01/07/CO1/截屏2022-12-26 23.38.46.png" alt="截屏2022-12-26 23.38.46" style="zoom:50%;"></p>
<h3 id="计算机层级结构"><a href="#计算机层级结构" class="headerlink" title="计算机层级结构"></a>计算机层级结构</h3><p><img src="/2023/01/07/CO1/截屏2022-12-26 23.40.47.png" alt="截屏2022-12-26 23.40.47" style="zoom: 33%;"></p>
<p><strong>ISA 是软件和硬件的界面（Interface，接口），也是计算机组成（organization）的抽象 / 接口，或者说一种计算机组成是某种 ISA 的实现。</strong></p>
<p><strong>应用程序二进制接口（Application Binary Interface，ABI）是运行在特定 ISA 及特定操作系统之上的应用程序中所遵循的一种机器级目标代码层接口，它描述了应用程序和操作系统之间、应用程序和所调用的库之间、不同组成部分（如过程或函数）之间在较低层次上的机器级代码接口。</strong></p>
<blockquote>
<p>ABI 接口规约的内容主要包括</p>
<ul>
<li>过程间的调用规定</li>
<li>系统调用规定</li>
<li>目标文件的二进制格式</li>
<li>函数库使用规定</li>
<li>寄存器使用规定</li>
<li>程序的虚拟地址空间划分等</li>
</ul>
</blockquote>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul>
<li><p>并发：逻辑上的并行，<strong>物理上的交替执行</strong>（使系统同时处理多个任务）</p>
</li>
<li><p>并行：物理上的并行（真正使系统运行更快）</p>
<blockquote>
<p>指令级并行：流水线技术</p>
<p>超标量并行：多条流水线并行执行；动态多发射，一个时钟内发射多条指令，一个周期内可执行一条以上的指令</p>
</blockquote>
</li>
</ul>
<h2 id="02-数制与运算"><a href="#02-数制与运算" class="headerlink" title="02 数制与运算"></a>02 数制与运算</h2><h3 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h3><ul>
<li><p>十进制转二进制：整数部分除以 2 所得余数逆序，小数部分乘 2 所得整数正序</p>
<p><img src="/2023/01/07/CO1/截屏2022-12-26 23.59.19.png" alt="截屏2022-12-26 23.59.19" style="zoom:40%;"></p>
</li>
<li><p>二进制转十进制：整数部分从个位向高位乘以权重$1,2,4,8,\dots$；小数部分从十分位向低位乘以权重$\frac{1}{2},\frac{1}{4},\frac{1}{8},\dots$</p>
</li>
<li><p>二进制转十六进制：四位一组，整数部分高位补 0，小数部分低位补 0</p>
</li>
</ul>
<h3 id="定点数的编码"><a href="#定点数的编码" class="headerlink" title="定点数的编码"></a>定点数的编码</h3><div class="table-container">
<table>
<thead>
<tr>
<th>编码方式</th>
<th>正数</th>
<th>负数</th>
</tr>
</thead>
<tbody>
<tr>
<td>原码</td>
<td>符号位为 0</td>
<td>符号位为 1</td>
</tr>
<tr>
<td>反码</td>
<td>符号位为 0</td>
<td>对应正数按位取反</td>
</tr>
<tr>
<td>补码</td>
<td>符号位为 0</td>
<td>对应正数按位取反 + 1</td>
</tr>
<tr>
<td>移码</td>
<td>带偏移量的编码</td>
<td>带偏移量的编码</td>
</tr>
</tbody>
</table>
</div>
<h3 id="补码运算规则"><a href="#补码运算规则" class="headerlink" title="补码运算规则"></a>补码运算规则</h3><script type="math/tex; mode=display">
\begin{split}
[X+Y]_{补}=[X]_{补}+[Y]_{补}\\
[X-Y]_{补}=[X]_{补}+[-Y]_{补}
\end{split}</script><p><strong>若符号位产生进位，则将进位舍弃</strong></p>
<h3 id="浮点数的编码：IEEE-754"><a href="#浮点数的编码：IEEE-754" class="headerlink" title="浮点数的编码：IEEE 754"></a>浮点数的编码：IEEE 754</h3><p><img src="/2023/01/07/CO1/截屏2022-12-27 11.35.56.png" alt="截屏2022-12-27 11.35.56" style="zoom:40%;"></p>
<ul>
<li>数符 S：0 表示正数，1 表示负数</li>
<li>阶码 E：用移码表示，是非负整数，对于单精度浮点数偏移 +127，对于双精度浮点数偏移 +1023</li>
<li>尾数 M：必须规格化为小数点左侧一定为 1，且这个 1 作为隐含位被省略。例如，单精度浮点数的尾数实际为 24 位</li>
</ul>
<h3 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h3><p>地址总是从小到大排放的。访问一个数，或者说数的地址，总是低地址的那头。因此大小端指的是谁放在低位的问题。</p>
<ul>
<li>大端方式：数的高位所在的地址是数的地址</li>
<li>小端方式：数的低位所在的地址是数的地址</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 12.09.41.png" alt="截屏2022-12-27 12.09.41" style="zoom:50%;"></p>
<h3 id="布尔代数与门电路"><a href="#布尔代数与门电路" class="headerlink" title="布尔代数与门电路"></a>布尔代数与门电路</h3><h4 id="1-异或与同或"><a href="#1-异或与同或" class="headerlink" title="1. 异或与同或"></a>1. 异或与同或</h4><script type="math/tex; mode=display">
\begin{split}
A\oplus B&=A\overline{B}+\overline{A}B\\
A\odot B&=\overline{A}\ \overline{B}+AB\\
A\oplus B&=\overline{A\odot B}
\end{split}</script><h4 id="2-逻辑门电路的表示"><a href="#2-逻辑门电路的表示" class="headerlink" title="2. 逻辑门电路的表示"></a>2. 逻辑门电路的表示</h4><p><img src="/2023/01/07/CO1/截屏2022-12-27 12.26.53.png" alt="截屏2022-12-27 12.26.53" style="zoom: 45%;"></p>
<h4 id="3-逻辑代数基本公理"><a href="#3-逻辑代数基本公理" class="headerlink" title="3. 逻辑代数基本公理"></a>3. 逻辑代数基本公理</h4><ul>
<li><p>交换律</p>
<script type="math/tex; mode=display">
\begin{split}
A + B&=B+A\\
AB&=BA
\end{split}</script></li>
<li><p>结合律</p>
<script type="math/tex; mode=display">
\begin{split}
(A+B)+C&=A+(B+C)\\
(AB)C&=A(BC)\\
\end{split}</script></li>
<li><p>分配律</p>
<script type="math/tex; mode=display">
\begin{split}
A(B+C)&=AB+AC\\
A+BC&=(A+B)(A+C)
\end{split}</script></li>
<li><p>0 - 1律</p>
<script type="math/tex; mode=display">
\begin{split}
A+0=A,\ A\cdot1=A\\
A+1=1,\ A\cdot 0 = 0
\end{split}</script></li>
<li><p>互补律</p>
<script type="math/tex; mode=display">
\begin{split}
A+\overline{A}=1\\
A\overline{A}=0
\end{split}</script></li>
</ul>
<h4 id="4-逻辑代数基本定理"><a href="#4-逻辑代数基本定理" class="headerlink" title="4. 逻辑代数基本定理"></a>4. 逻辑代数基本定理</h4><ul>
<li><p>重叠律</p>
<script type="math/tex; mode=display">
\begin{split}
A+A=A
\\A\cdot A=A
\end{split}</script></li>
<li><p>还原律</p>
<script type="math/tex; mode=display">
\overline{\overline{A}}=A</script></li>
<li><p>反演律</p>
<script type="math/tex; mode=display">
\begin{split}
\overline{A+B}&=\overline{A}\cdot \overline{B}\\
\overline{A\cdot B}&=\overline{A} +\overline{B}
\end{split}</script></li>
<li><p><strong>吸收律 1</strong></p>
<script type="math/tex; mode=display">
\begin{split}
A+A\cdot B&=A\\ A\cdot(A+B)&=A
\end{split}</script></li>
<li><p><strong>吸收律 2</strong></p>
<script type="math/tex; mode=display">
A+\overline{A}B=A +B</script></li>
<li><p><strong>包含律</strong></p>
<script type="math/tex; mode=display">
\begin{split}
A\cdot B+\overline{A}\cdot C+B\cdot C&=A\cdot B+\overline{A}\cdot C\\
(A+B)\cdot(\overline{A}+C)\cdot(B+C)&=(A+B)\cdot(\overline{A}+C)\\
A\cdot B+\overline{A}\cdot C + BCDEF\cdots&=A\cdot B+\overline{A}\cdot C
\end{split}</script></li>
</ul>
<h4 id="5-逻辑代数的规则"><a href="#5-逻辑代数的规则" class="headerlink" title="5. 逻辑代数的规则"></a>5. 逻辑代数的规则</h4><ul>
<li><p>代入定理</p>
</li>
<li><p><strong>反演定理</strong></p>
<p>$\begin{split}&amp;将原函数F中的全部\cdot换成+，+换成\cdot，0\ 换成\ 1，1\ 换成\ 0，原变量换成反变量，\\&amp;反变量换成原变量，得到的就是F的反函数\overline{F}(取反只取单个变量上的非号)\end{split}$</p>
</li>
<li><p><strong>对偶定理</strong></p>
<p>$\begin{split}&amp;将原函数F中的全部\cdot换成+，+换成\cdot，0\ 换成\ 1，1\ 换成\ 0，就得到原函数F的\\&amp;对偶式F’(F^*).\ 若F=G，则F’=G’\end{split}$</p>
</li>
</ul>
<h4 id="6-最小项与最大项"><a href="#6-最小项与最大项" class="headerlink" title="6. 最小项与最大项"></a>6. 最小项与最大项</h4><ul>
<li><strong>最小项</strong><ul>
<li>$n$ 个变量有 $2^n$ 个最小项</li>
<li>按照变量顺序将最小项中原变量用 $1$ 表示、反变量用 $0$ 表示，得到的二进制数对应的十进制数即为该最小项的编号 $i$</li>
<li>性质<ul>
<li>对于任意最小项，只有一组变量取值使之为 1</li>
<li>全体最小项之和为 1</li>
<li>任意两个最小项乘积为 0</li>
<li>除了一个变量互为反变量外，其余变量都相同的两个最小项称相邻最小项。<strong>具有相邻性的最小项之和可以合并为一个乘积项</strong>，如$\overline{A}\ \overline{B}\ \overline{C}+\overline{A}\ \overline{B}\ C=\overline{A}\ \overline{B}$</li>
</ul>
</li>
<li>最小项推导法：使输出为 1 的输入组合写成乘积项的形式，其中取值为 1 的输入用原变量表示，取值为 0 的输入用反变量表示，然后把这些乘积项加起来</li>
</ul>
</li>
<li><strong>最大项</strong><ul>
<li>$n$ 个变量有 $2^n$ 个最大项</li>
<li>按照变量顺序将最小项中原变量用 $0$ 表示、反变量用 $1$ 表示，得到的二进制数对应的十进制数即为该最小项的编号 $i$ 。规律：$m_i=\overline{M_i}$</li>
<li>性质<ul>
<li>对于任意最大项，只有一组变量取值使之为 0</li>
<li>全体最大项之积为 0</li>
<li>任意两个最大项之和为 1</li>
<li><strong>具有相邻性的最大项之积可以合并为一个和项</strong>，例如$(\overline{A}+B+\overline{C})(A+B+\overline{C})=B+\overline{C}$</li>
</ul>
</li>
<li>最大项推导法：把使输出为 0 的输入组合写成和项的形式，其中取值为 0 的输入用原变量表示，取值为 1 的输入用反变量表示，然后把这些和项乘起来</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>补充：BCD 码</strong></p>
<p>将十进制数的数码转变为四位二进制数，即为 BCD 编码。常见的有 8421BCD、2421BCD、5211BCD 和 余 3 BCD 等。其中数字代表对应二进制位的权重。</p>
<ul>
<li>余 3 BCD：将 8421BCD 加上 3 即得余 3 BCD</li>
</ul>
</blockquote>
<h2 id="03-数字逻辑"><a href="#03-数字逻辑" class="headerlink" title="03 数字逻辑"></a>03 数字逻辑</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p><strong>数字电路分为组合逻辑和时序逻辑</strong></p>
<blockquote>
<p><strong>组合逻辑电路</strong></p>
<ul>
<li>将逻辑门以一定的方式组合在一起，使其具有一定逻辑功能的数字电路。<em>**</em></li>
<li>组合逻辑电路是一种<strong>无记忆</strong>电路——任一时刻的输出信号仅取决于该时刻的输入信号，而与信号作用前电路原来所处的状态无关。</li>
<li>特点<ul>
<li>由逻辑门电路组成</li>
<li><strong>没有反馈电路和储存电路</strong></li>
<li>某时刻输出仅由该时刻输入决定（速度快）</li>
</ul>
</li>
</ul>
<p><strong>时序逻辑电路</strong></p>
<ul>
<li>时序逻辑电路由组合逻辑电路和存储电路构成，具有<strong>记忆功能</strong>。</li>
<li>某一时刻的输出由该时刻的输入和电路当前状态有关。</li>
<li>触发器（Flip-Flop，FF）是构成记忆功能部件的基本单元。触发器有两个互非的输出 $Q$ 和 $\overline{Q}$，其中 $Q$ 称为<strong>状态变量</strong>。在外加信号的触发下，触发器可由<strong>原态</strong> $Q^n$ 变为<strong>次态</strong> $Q^{n+1}$。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><h4 id="1-加法运算电路"><a href="#1-加法运算电路" class="headerlink" title="1. 加法运算电路"></a>1. 加法运算电路</h4><ul>
<li><p>半加器：对两个 1 位二进制数求和，并向高位进位，<strong>不考虑来自低位的进位</strong></p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 16.53.50.png" alt="截屏2022-12-27 16.53.50" style="zoom:40%;"></p>
<script type="math/tex; mode=display">
\begin{split}
C_O&=A\cdot B\\
S_0=\overline{A}B&+A\overline{B}=A\oplus B
\end{split}</script></li>
<li><p>全加器：对两个 1 位二进制数求和，并向高位进位，<strong>考虑来自低位的进位</strong></p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 16.56.49.png" alt="截屏2022-12-27 16.56.49" style="zoom:40%;"></p>
<script type="math/tex; mode=display">
\begin{split}
S_0=A&\oplus B\oplus C_I\\
C_O =AB&+C_I(A\oplus B)
\end{split}</script></li>
<li><p>多位加法器通过<strong>并行进位（先行进位）</strong>减少延时，但实现相对复杂。</p>
</li>
<li><p><strong>溢出问题</strong></p>
<blockquote>
<p>溢出的可能情形</p>
<ul>
<li>符号位相同的两数相加，所得结果符号位发生变化，则溢出</li>
<li>符号位相异的两数相减，所得结果符号位与减数相同，则溢出</li>
</ul>
<p>有符号数运算时，出现溢出表示结果是错误的。</p>
<p>采用<strong>双符号位</strong>判断溢出</p>
<ul>
<li>00 表示正，11 表示负</li>
<li>运算结果出现 01 为正溢</li>
<li>运算结果出现 10 为负溢</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="2-数值比较器"><a href="#2-数值比较器" class="headerlink" title="2. 数值比较器"></a>2. 数值比较器</h4><ul>
<li><p>一位比较器</p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 17.04.17.png" alt="截屏2022-12-27 17.04.17" style="zoom:50%;"></p>
<script type="math/tex; mode=display">
\begin{split}
F_{A>B}=A&\overline{B}=A\overline{AB}\\
F_{A=B}=AB+\overline{AB}&=\overline{A\overline{AB}+B\overline{AB}}\\
F_{A<B}=\overline{A}&B=B\overline{AB}
\end{split}</script></li>
<li><p>多位比较器（4 位比较器，7485 芯片）</p>
<blockquote>
<p>比较规则：规则：从高位开始比较，高位不等时，数值的大小由高位决定；若高位相等，则再比较低位，数值的大小由低位比较结果决定。</p>
</blockquote>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 17.08.35.png" alt="截屏2022-12-27 17.08.35" style="zoom:40%;"></p>
</li>
<li><p><strong>数位拓展：将低位芯片的输出作为高位芯片在高位各位全相等时的输入，并原样输出。</strong></p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 17.11.43.png" alt="截屏2022-12-27 17.11.43" style="zoom:35%;"></p>
</li>
</ul>
<h4 id="3-ALU"><a href="#3-ALU" class="headerlink" title="3. ALU"></a>3. ALU</h4><ul>
<li><p>具备加法、减法、与、或运算的一位 ALU</p>
<blockquote>
<p>根据 $[X-Y]_{补}=[X]_{补}+[Y]_{补}=[X]+[Y]_{反}+1$，对于减法，<strong>只需要将第二个操作数取反，并将低位进位置一即可。</strong>对第二个操作数是否取反的二选一多选器，设 Binvert 信号取 0 时保持原数，取 1 取反；另设低位进位为 CarryIn。则对于加法，Binvert = 0，CarryIn = 0；对于减法，Binvert = 1，CarryIn = 1。故可以连到一根线上，设该信号为 Bnegate。</p>
</blockquote>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 17.43.06.png" alt="截屏2022-12-27 17.43.06" style="zoom:50%;"></p>
</li>
<li><p><strong>$n$ 位带标志的 ALU</strong></p>
<ul>
<li><p>溢出标志</p>
<script type="math/tex; mode=display">
{\rm OF}={\rm Cin}_{n-1}\oplus {\rm Cout}_{n-1}</script></li>
<li><p>符号标志</p>
<script type="math/tex; mode=display">
{\rm SF}={\rm F}_{n-1}</script></li>
<li><p>零标志</p>
<script type="math/tex; mode=display">
{\rm ZF} = 1\Leftrightarrow {\rm F }=0</script></li>
<li><p>进位 / 借位标志</p>
<script type="math/tex; mode=display">
{\rm CF}={\rm Cin}_0 \ \oplus\ {\rm Cout}_{n-1}</script></li>
</ul>
<blockquote>
<p>条件标志（Flag）在运算电路中产生，被记录到专门的<strong>程序 / 状态字寄存器或标志寄存器</strong>中。</p>
</blockquote>
</li>
</ul>
<h4 id="4-编码器"><a href="#4-编码器" class="headerlink" title="4. 编码器"></a>4. 编码器</h4><ul>
<li><p>$2^n$ 线 - $n$ 线编码器：用 $n$ 位二进制代码对 $2^n$ 个信号进行编码。任意一个时刻只能对其中一个信号编码，其余信号为无效电平，否则输出会混乱</p>
<p>8 线 - 3 线编码器（输入高电平有效）：</p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 17.59.33.png" alt="截屏2022-12-27 17.59.33" style="zoom:40%;"></p>
<script type="math/tex; mode=display">
\begin{split}
A=Y_1+Y_3+Y_5+Y_7=\overline{\overline{Y_1}\cdot\overline{Y_3}\cdot \overline{Y_5}\cdot \overline{Y_7}}\\
B=Y_2+Y_3+Y_6+Y_7=\overline{\overline{Y_2}\cdot\overline{Y_3}\cdot \overline{Y_6}\cdot \overline{Y_7}}\\
C=Y_4+Y_5+Y_6+Y_7=\overline{\overline{Y_4}\cdot\overline{Y_5}\cdot \overline{Y_6}\cdot \overline{Y_7}}
\end{split}</script></li>
<li><p>优先编码器：允许多个输入，<strong>仅对优先级最高的信号编码输出</strong></p>
<ul>
<li>74LS148：8 线 - 3 线优先编码器，输入低电平有效，反码输出</li>
<li>74LS147：10线 - 4 线优先编码器，输入低电平有效，反码输出</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 18.05.06.png" alt="截屏2022-12-27 18.05.06" style="zoom:25%;"></p>
</li>
</ul>
<h4 id="5-译码器"><a href="#5-译码器" class="headerlink" title="5. 译码器"></a>5. 译码器</h4><ul>
<li><p>二进制译码器（变量译码器）</p>
<p>74LS138：3 线 - 8 线译码器</p>
<ul>
<li>输入高电平有效</li>
<li>输出低电平有效</li>
<li>有三个使能控制 $S_1,\ S_2,\ S_3$ ，只有当它们分别为 1，0，0 时译码器才能正常工作</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 18.10.56.png" alt="截屏2022-12-27 18.10.56" style="zoom:30%;"></p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 18.12.46.png" alt="截屏2022-12-27 18.12.46" style="zoom:30%;"></p>
</li>
<li><p>BCD 译码器</p>
</li>
<li><p>显示译码器</p>
<ul>
<li>使用共阴极 LED 数码管：译码器输出高电平有效</li>
<li>使用共阳极 LED 数码管：译码器输出低电平有效</li>
</ul>
</li>
</ul>
<h4 id="6-多路选择器"><a href="#6-多路选择器" class="headerlink" title="6. 多路选择器"></a>6. 多路选择器</h4><ul>
<li><p>8 选 1 多路选择器</p>
<p>$D_7\sim D_0$ 为数据输入端，$A_2A_1A_0$ 为选择控制端，使能信号 ${\rm EN}$ 低电平有效</p>
</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 18.19.49.png" alt="截屏2022-12-27 18.19.49" style="zoom:50%;"></p>
<script type="math/tex; mode=display">
\begin{split}
Y=\ &\overline{A_2}\ \overline{A_1}\ \overline{A_0}D_0+\overline{A_2}\ \overline{A_1}A_0D_1+\overline{A_2}A_1\overline{A_0}D_2+\overline{A_2}A_1A_0D_3\\
&+A_2\overline{A_1}\ \overline{A_0}D_4+A_2\overline{A_1}A_0D_5+A_2A_1\overline{A_0}D_6+A_2A_1A_0D_7\\
=\ &D_0m_0+D_1m_1+D_2m_2+D_3m_3\\
&+D_4m_4+D_5m_5+D_6m_6+D_7m_7

\end{split}</script><ul>
<li><strong>利用多选器实现逻辑函数：将逻辑函数化为由最小项组成的与或式，若有项 $m_i$ 则将 $D_i$ 接高电平；反之低电平。</strong></li>
</ul>
<h3 id="竞争冒险现象"><a href="#竞争冒险现象" class="headerlink" title="竞争冒险现象"></a>竞争冒险现象</h3><ul>
<li><p>相关概念</p>
<ul>
<li>竞争：在组合逻辑电路中，某个输入变量通过两条或两条以上的途径传到输出端，由于每条途径延迟时间不同，到达输出门的时间就有先有后，这种（两个或多个信号不同步）现象称为竞争。</li>
<li>冒险：门电路因输入端的竞争而导致输出端产生不正常的尖峰干扰冒充信号（毛刺）的现象，成为冒险。</li>
<li><strong>竞争冒险的原因：门电路的延时。</strong></li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 19.04.06.png" alt="截屏2022-12-27 19.04.06" style="zoom:40%;"></p>
</li>
<li><p>解决方案</p>
<ul>
<li>修改设计逻辑：消除互补变量 / 增加冗余项</li>
<li>引入采样脉冲</li>
<li>输出端并联电容</li>
</ul>
</li>
</ul>
<h3 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h3><h4 id="1-RS-锁存器"><a href="#1-RS-锁存器" class="headerlink" title="1. RS 锁存器"></a>1. RS 锁存器</h4><ul>
<li><p>基本 RS 锁存器</p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 20.28.40.png" alt="截屏2022-12-27 20.28.40" style="zoom:50%;"></p>
<ul>
<li>特性方程 $Q^{n+1}=S_D+\overline{R_D}\cdot Q^n$</li>
<li>约束条件 $S_D\cdot R_D = 0\ (\overline{S_D}\ 和\ \overline{R_D}\ 不能同时为\ 0)$</li>
</ul>
</li>
<li><p>钟控 RS 锁存器</p>
<ul>
<li>有时钟控制端的锁存器称为钟控锁存器，只有当时钟信号为<strong>高电位或低电位</strong>时，锁存器的状态才会随输入变化。钟控锁存器是<strong>电位触发方式</strong>的锁存器。</li>
<li>钟控锁存器在时钟控制下同步工作，又称<strong>同步锁存器</strong>。</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 20.36.34.png" alt="截屏2022-12-27 20.36.34" style="zoom:30%;"></p>
<ul>
<li>特性方程 $Q^{n+1}=S+\overline{R}\cdot Q^n({\rm CP}\ 为\ 0\ 时处于保持状态)$</li>
<li>约束条件 $S\cdot R=0$</li>
</ul>
</li>
</ul>
<h4 id="2-钟控-D-锁存器"><a href="#2-钟控-D-锁存器" class="headerlink" title="2. 钟控 D 锁存器"></a>2. 钟控 D 锁存器</h4><p><img src="/2023/01/07/CO1/截屏2022-12-27 20.41.21.png" alt="截屏2022-12-27 20.41.21" style="zoom:50%;"></p>
<ul>
<li>特性方程 $Q^{n+1}=D({\rm CP}\ 为\ 0\ 时处于保持状态)$</li>
</ul>
<h4 id="3-D-触发器"><a href="#3-D-触发器" class="headerlink" title="3. D 触发器"></a>3. D 触发器</h4><blockquote>
<p><strong>触发器的状态变化只发生在时钟信号的有效沿（上升沿或下降沿）。</strong></p>
</blockquote>
<ul>
<li><p>基本的 D 触发器</p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 20.46.46.png" alt="截屏2022-12-27 20.46.46" style="zoom:50%;"></p>
<ul>
<li>CP = 0 时，L1 通 L2 断，Q1 为 D 的值，Q2 的值保持不变</li>
<li>CP 上升沿，Q1 的值赋给 Q2，这是触发时刻</li>
<li>CP = 1 时，L1 断 L2 通，Q1 不变则 Q2 继续保持</li>
</ul>
</li>
<li><p>加入使能信号 EN</p>
<ul>
<li>EN = 1 时触发器正常工作</li>
<li>EN = 0 时触发器状态保持</li>
<li>一般不在时钟信号上设置逻辑，否则可能因为延迟导致时序错误</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 20.51.27.png" alt="截屏2022-12-27 20.51.27" style="zoom:50%;"></p>
</li>
<li><p>复位功能</p>
<ul>
<li>RESET 为低电平（有效）时，触发器复位（Q = 0）；为高电平（无效）时，正常工作</li>
<li>复位方式<ul>
<li>同步复位：复位信号和时钟有效沿同时到来才能复位</li>
<li>异步复位：只要有复位信号就可以复位</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 20.54.19.png" alt="截屏2022-12-27 20.54.19" style="zoom:50%;"></p>
</li>
</ul>
<h4 id="4-JK-触发器"><a href="#4-JK-触发器" class="headerlink" title="4. JK 触发器"></a>4. JK 触发器</h4><ul>
<li><p>JK 触发器将 R = 1，S = 1 的无效状态变成了翻转功能。</p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 20.57.21.png" alt="截屏2022-12-27 20.57.21" style="zoom:50%;"></p>
</li>
<li><p>特性方程 $Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n$</p>
</li>
</ul>
<h4 id="5-有限状态机（FSM）"><a href="#5-有限状态机（FSM）" class="headerlink" title="5. 有限状态机（FSM）"></a>5. 有限状态机（FSM）</h4><ul>
<li><p>Moore 型：输入仅改变状态，输出仅与当前状态有关。</p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 21.03.46.png" alt="截屏2022-12-27 21.03.46" style="zoom:50%;"></p>
</li>
<li><p>Mealy 型：输出与状态和输入都有关。</p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 21.04.47.png" alt="截屏2022-12-27 21.04.47" style="zoom:60%;"></p>
</li>
</ul>
<h4 id="6-计数器"><a href="#6-计数器" class="headerlink" title="6. 计数器"></a>6. 计数器</h4><ul>
<li><p>分类</p>
<ul>
<li>按时钟连接方式：同步计数器和异步计数器</li>
<li>按计数方式：二进制计数器、十进制计数器、M 进制计数器</li>
<li>按状态变化方式：加法计数器、减法计数器、加 / 减法计数器</li>
</ul>
</li>
<li><p>计数器特性分析</p>
<blockquote>
<p>计数器 —— 若干触发器通过若干状态构成一个计数循环</p>
<p>同步 —— 所有触发器的时钟端连在一起</p>
<p>M 进制 —— 计数循环的状态个数为 M（模 M 计数器）</p>
<p>加 / 减法 —— 计数状态按递增 / 减方向变化</p>
<p>自启动性 —— 不存在由计数循环以外的状态构成的死循环，在无效状态也能回到计数循环中来</p>
</blockquote>
</li>
<li><p>二进制加法计数器特点</p>
<ul>
<li>触发器的模值是 $2^n$。</li>
<li>二进制计数器没有非编码状态，因此不存在不能自启动的问题。</li>
<li>不同的触发器的周期分别是计数脉冲 CP 的 2 倍、4 倍、8倍、16倍、… ，则相当于对 CP 波形进行了 2 分频、4 分频、8 分频、16 分频、… ，因此二进制计数器也成为<strong>分频器</strong>。</li>
</ul>
</li>
<li><p>集成计数器与改变模值</p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 21.28.07.png" alt="截屏2022-12-27 21.28.07" style="zoom:50%;"></p>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 21.32.39.png" alt="截屏2022-12-27 21.32.39" style="zoom:30%;"></p>
<blockquote>
<p>设一个计数器的模值为 $M$，则两片级联后模值变为 $M^2$</p>
</blockquote>
<ul>
<li><p><strong>反馈复位法：通过级联使模值充分够，当计数到指定模值后强行复位。</strong></p>
<blockquote>
<p>用两片 74LS161 实现 M = 60 的加法计数器</p>
<ul>
<li>反馈复位条件 $(60)_{10}=(111100)_2$</li>
<li>反馈复位逻辑 $\overline{R_D}=\overline{Q_5Q_4Q_3Q_2}$</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 21.37.44.png" alt="截屏2022-12-27 21.37.44" style="zoom:50%;"></p>
</blockquote>
</li>
<li><p><strong>预置法</strong></p>
<blockquote>
<p>(1) 输出 C 预置法：产生进位（数到头）后将计数器预置到某一中间值。</p>
<p>用一片 74LS161 实现 M = 10 的加法计数器</p>
<ul>
<li>预置数据 $(16-10)_{10}=(6)_10=(0110)_2=D_3D_2D_1D_0$（从 6 开始数）</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 21.43.56.png" alt="截屏2022-12-27 21.43.56" style="zoom:50%;"></p>
<p>(2) 输出 Q 预置法：到达指定模值后将计数器预置到 0。</p>
<p>用一片 74LS161 实现 M = 10 的加法计数器</p>
<ul>
<li>预置条件 $(10-1)_{10}=(9)_{10}=(1001)_2$</li>
<li>预置逻辑 $\overline{LD}=\overline{Q_3Q_0}$</li>
</ul>
<p><img src="/2023/01/07/CO1/截屏2022-12-27 21.51.16.png" alt="截屏2022-12-27 21.51.16" style="zoom:50%;"></p>
<p>注意预置 Q 与反馈复位的区别：前者通过预置复位到 0，预置本身需要花费一个时钟（因为要等下一个有效沿到来），因此预置的条件是模值 M - 1；而后者通过 Reset 方式直接强行复位到 0。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="04-MIPS-汇编"><a href="#04-MIPS-汇编" class="headerlink" title="04 MIPS 汇编"></a>04 MIPS 汇编</h2><h3 id="MIPS-寻址方式"><a href="#MIPS-寻址方式" class="headerlink" title="MIPS 寻址方式"></a>MIPS 寻址方式</h3><ul>
<li>立即寻址：操作数直接在指令中给出，如<code>addi $s1, $s2, 100</code></li>
<li>寄存器直接寻址：访问寄存器中的操作数，如<code>add $t1, $t2, $t3</code></li>
<li>寄存器间接寻址：访问寄存器中的地址，进而访问位于该地址的操作数，如<code>lw $t0, 0($t1)</code></li>
<li>基址寻址：访问寄存器中的基址，进而访问位于“基址 + 偏移量”处的操作数，如<code>lw $t0, 100($t1)</code></li>
<li>变址寻址：寄存器中存有偏移量，通过数组名（形式地址）+ 偏移量的方式访问操作数，如<code>lb $t1, arr($t0)</code></li>
<li>相对寻址：基址寻址的特例，基址存在于程序计数器 PC 中，如<code>beq $t1, $t2, 100</code></li>
</ul>
<h3 id="MIPS-寄存器结构"><a href="#MIPS-寄存器结构" class="headerlink" title="MIPS 寄存器结构"></a>MIPS 寄存器结构</h3><ul>
<li><p>组成</p>
<ul>
<li>32 位（4G）虚拟地址空间</li>
<li>32 个 32 位通用寄存器（GPRs）</li>
<li>32 个 32 位浮点数寄存器（FPRs）</li>
<li>乘除寄存器 HI LO</li>
<li>程序计数器 PC</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">编号</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">zero</td>
<td style="text-align:center">0</td>
<td>恒为常数 0</td>
</tr>
<tr>
<td style="text-align:center">at</td>
<td style="text-align:center">1</td>
<td>为汇编程序保留</td>
</tr>
<tr>
<td style="text-align:center">v0 ~ v1</td>
<td style="text-align:center">2 ~ 3</td>
<td>过程调用返回值</td>
</tr>
<tr>
<td style="text-align:center">a0 ~ a3</td>
<td style="text-align:center">4 ~7</td>
<td>过程调用参数</td>
</tr>
<tr>
<td style="text-align:center">t0 ~ t7</td>
<td style="text-align:center">8 ~ 15</td>
<td>临时变量</td>
</tr>
<tr>
<td style="text-align:center">s0 ~ s7</td>
<td style="text-align:center">16 ~ 23</td>
<td>保存</td>
</tr>
<tr>
<td style="text-align:center">t8 ~ t9</td>
<td style="text-align:center">24 ~ 25</td>
<td>其他临时变量</td>
</tr>
<tr>
<td style="text-align:center">k0 ~ k1</td>
<td style="text-align:center">26 ~ 27</td>
<td>为 OS 保留</td>
</tr>
<tr>
<td style="text-align:center">gp</td>
<td style="text-align:center">28</td>
<td>全局指针</td>
</tr>
<tr>
<td style="text-align:center">sp</td>
<td style="text-align:center">29</td>
<td>栈指针</td>
</tr>
<tr>
<td style="text-align:center">fp</td>
<td style="text-align:center">30</td>
<td>帧指针</td>
</tr>
<tr>
<td style="text-align:center">ra</td>
<td style="text-align:center">31</td>
<td>过程调用返回地址</td>
</tr>
</tbody>
</table>
</div>
<h3 id="MIPS-指令格式"><a href="#MIPS-指令格式" class="headerlink" title="MIPS 指令格式"></a>MIPS 指令格式</h3><blockquote>
<ul>
<li>R-Type（Register）：两个寄存器操作数计算，结果送给第三个寄存器（寄存器相关的指令）</li>
<li>I-Type（Immediate）：含有带符号 16 位立即数操作的指令</li>
<li>J-Type（Jump）：跳转指令，包含 26 位跳转地址</li>
</ul>
</blockquote>
<h4 id="1-R-指令"><a href="#1-R-指令" class="headerlink" title="1. R 指令"></a>1. R 指令</h4><blockquote>
<p><strong>6 位操作码 Op：全 0</strong></p>
<p>3 × 5 位寄存器编号：分别代表 Rs、Rt、Rd</p>
<p><strong>5 位偏移量：仅用于移位运算</strong></p>
<p>6 位 Func 字段：表示具体运算类型</p>
</blockquote>
<ul>
<li><p>三个操作数全为寄存器 <code>add rd, rs, rt # rd &lt;- (rs + rt)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add $t0, $s1, $s2 # 000000 10001 10010 01000 00000 100000</span><br></pre></td></tr></table></figure>
</li>
<li><p>移位运算 <code>sll rd, rt, sa # rd &lt;- (rt &lt;&lt; sa)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sll $8, $9, 10 # 000000 00000 01001 01000 01010 000000</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄存器无条件跳转</p>
<ul>
<li><p><code>jr rs # PC &lt;- rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jr $8 # 000000 01000 00000 00000 00000 001000</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>jalr rd, rs # rd &lt;- return_addr; PC &lt;- rs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jalr $8, $9 # 000000 01001 00000 01000 00000 001001</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="2-I-指令"><a href="#2-I-指令" class="headerlink" title="2. I 指令"></a>2. I 指令</h4><blockquote>
<p>6 位操作码 Op：表示对应的算数 / 逻辑运算或存取操作</p>
<p>2 × 5 位寄存器编号：分别表示 Rs 和 Rt</p>
<p><strong>16 位带符号立即数</strong></p>
</blockquote>
<ul>
<li><p>带立即数的算数 / 逻辑运算<code>addi rt, rs, imm # rt &lt;- (rs + imme)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addi $8, $9, 10 # 001000 01000 01001 0000000000001010</span><br></pre></td></tr></table></figure>
</li>
<li><p>存取指令<code>ld rt, offset(rs) # rt &lt;- Mem[rs + offset]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld $8, 4($9) # 110111 01001 01000 0000000000000100</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件跳转指令<code>beq rs, rt, offset # if (rs == rt) then PC &lt;- PC + offset</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beq $8, $9, -4 # 000100 01000 01001 1111111111111100</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-J-指令"><a href="#3-J-指令" class="headerlink" title="3. J 指令"></a>3. J 指令</h4><blockquote>
<p>6 位操作码 Op：表示对应的跳转类型</p>
<p>26 位地址：跳转的地址（标签）</p>
</blockquote>
<ul>
<li><p>```assembly<br>j target # PC &lt;- (PC_4_Highest_Bits || instr_index || 00)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```assembly</span><br><span class="line">  jal target # ra &lt;- (PC + 8); PC &lt;- (PC_4_Highest_Bits || instr_index || 00)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跳转指令的范围问题</strong></p>
<blockquote>
<ul>
<li><code>j</code>指令：跳转时 26 位地址低位补两个 0，高 4 位接上 PC + 4 的高四位，可以跳转 $2^{28}$ 个地址单元，即 256 MB。</li>
<li><code>jr</code>指令：属于 R 指令，地址为寄存器中的 32 位数，可以跳转全部的 $2^{32}$ 个地址单元，即 4GB。</li>
<li><code>beq</code>指令：属于 I 指令，将 16 位立即数低位补两个 0，符号扩展成 32 位后加上 PC + 4，可以跳转 $2^{18}$ 个地址单元，即 256 KB。</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>补充：伪指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># li $t0, 0x12345678</span><br><span class="line">lui $1, 0x1234 # $1 &lt;- 0x12340000(装载到高16位)</span><br><span class="line">ori $t0, $1, 0x5678</span><br><span class="line"></span><br><span class="line"># move $t1, $t2</span><br><span class="line">add $t1, $t2, $zero</span><br><span class="line"></span><br><span class="line"># la $t1, label</span><br><span class="line">addi $t1, $zero, 0x??? # 编译时刻确定的地址</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="系统调用syscall"><a href="#系统调用syscall" class="headerlink" title="系统调用syscall"></a>系统调用<code>syscall</code></h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">服务类型</th>
<th style="text-align:center">服务号 <code>v0</code></th>
<th>参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">打印整数</td>
<td style="text-align:center">1</td>
<td>a0 为要打印的整数</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">打印单精度浮点数</td>
<td style="text-align:center">2</td>
<td>f12 为要打印的浮点数</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">打印双精度浮点数</td>
<td style="text-align:center">3</td>
<td>f12 为要打印的浮点数</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">打印字符串</td>
<td style="text-align:center">4</td>
<td>a0 为字符串的地址</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">读取整数</td>
<td style="text-align:center">5</td>
<td></td>
<td>v0 存放读到的整数</td>
</tr>
<tr>
<td style="text-align:center">读取单精度浮点数</td>
<td style="text-align:center">6</td>
<td></td>
<td>f0 存放读到的浮点数</td>
</tr>
<tr>
<td style="text-align:center">读取双精度浮点数</td>
<td style="text-align:center">7</td>
<td></td>
<td>f0 存放读到的浮点数</td>
</tr>
<tr>
<td style="text-align:center">读取字符串</td>
<td style="text-align:center">8</td>
<td>a0 为字符串的起始地址，a1 为最多可以读取的字符个数</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">分配堆空间</td>
<td style="text-align:center">9</td>
<td>a0 为空间的字节数</td>
<td>v0 存放分配到的空间的首地址</td>
</tr>
<tr>
<td style="text-align:center">终止程序</td>
<td style="text-align:center">10</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">打印字符</td>
<td style="text-align:center">11</td>
<td>a0 为要打印的字符</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">读取字符</td>
<td style="text-align:center">12</td>
<td></td>
<td>v0 存放读到的字符</td>
</tr>
</tbody>
</table>
</div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Chou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/07/CO1/">http://example.com/2023/01/07/CO1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Riccardo's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/15/SP01/"><img class="prev-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux 系统编程｜概述</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/07/Sets/"><img class="next-cover" src="/img/background.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">离散数学｜集合论</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BUAA-Software-CO%EF%BD%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%811"><span class="toc-text">BUAA Software CO｜计算机组成原理概要1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E7%BB%AA%E8%AE%BA"><span class="toc-text">01 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9E%B6%E6%9E%84"><span class="toc-text">冯诺依曼架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8A%A0%E8%BD%BD"><span class="toc-text">程序编译与加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%B1%BB%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-text">两类指令集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84"><span class="toc-text">计算机层级结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-text">并行和并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E6%95%B0%E5%88%B6%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-text">02 数制与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">进制的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-text">定点数的编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-text">补码运算规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%EF%BC%9AIEEE-754"><span class="toc-text">浮点数的编码：IEEE 754</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-text">大小端存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E4%B8%8E%E9%97%A8%E7%94%B5%E8%B7%AF"><span class="toc-text">布尔代数与门电路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%82%E6%88%96%E4%B8%8E%E5%90%8C%E6%88%96"><span class="toc-text">1. 异或与同或</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">2. 逻辑门电路的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%85%AC%E7%90%86"><span class="toc-text">3. 逻辑代数基本公理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86"><span class="toc-text">4. 逻辑代数基本定理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">5. 逻辑代数的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%9C%80%E5%B0%8F%E9%A1%B9%E4%B8%8E%E6%9C%80%E5%A4%A7%E9%A1%B9"><span class="toc-text">6. 最小项与最大项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91"><span class="toc-text">03 数字逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91"><span class="toc-text">组合逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF"><span class="toc-text">1. 加法运算电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">2. 数值比较器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ALU"><span class="toc-text">3. ALU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-text">4. 编码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AF%91%E7%A0%81%E5%99%A8"><span class="toc-text">5. 译码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-text">6. 多路选择器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E5%86%92%E9%99%A9%E7%8E%B0%E8%B1%A1"><span class="toc-text">竞争冒险现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91"><span class="toc-text">时序逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-RS-%E9%94%81%E5%AD%98%E5%99%A8"><span class="toc-text">1. RS 锁存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%92%9F%E6%8E%A7-D-%E9%94%81%E5%AD%98%E5%99%A8"><span class="toc-text">2. 钟控 D 锁存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-D-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-text">3. D 触发器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-JK-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-text">4. JK 触发器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88FSM%EF%BC%89"><span class="toc-text">5. 有限状态机（FSM）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">6. 计数器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-MIPS-%E6%B1%87%E7%BC%96"><span class="toc-text">04 MIPS 汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MIPS-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">MIPS 寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MIPS-%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-text">MIPS 寄存器结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MIPS-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-text">MIPS 指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-R-%E6%8C%87%E4%BB%A4"><span class="toc-text">1. R 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-I-%E6%8C%87%E4%BB%A4"><span class="toc-text">2. I 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-J-%E6%8C%87%E4%BB%A4"><span class="toc-text">3. J 指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8syscall"><span class="toc-text">系统调用syscall</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Chou</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div></div></body></html>